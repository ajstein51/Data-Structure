#include <vector>
#include <iostream>
#include <iomanip>
using namespace std;

//*******************************************************************************************
template <typename T>
MinHeap<T>::MinHeap(){                                                        // Empty
  
}
//*******************************************************************************************
template <typename T>
MinHeap<T>::~MinHeap(){                                                       // Empty
 
}
//*******************************************************************************************
// Returns the min element, since we are doing a min heap the min element should always be the first element. 
template <typename T>
T MinHeap<T>::peek()const{
  if(heap.empty()){
    cout << "\nHeap is empty, ending program!" << endl;
    exit(1);
  } 
  else
    return heap[0].data;                                                     // first elements, also the lowest/min
}
//*******************************************************************************************
template <typename T>
void MinHeap<T>::insert(const T data, const int key) {  
  if(heap.empty())                                                           // If the heap is empty or otherwise this is the first node.(make new node)
    heap.push_back(HeapNode<T>(data, key)); 
  else{
    heap.push_back(HeapNode<T>(data, key));
    for(int i = heap.size() - 1; i != 0; i = (i - 1) / 2){
      if(heap[(i - 1) / 2].key > heap[i].key)
        swap(heap[i], heap[(i - 1) / 2]);
    }
  }
}
//*******************************************************************************************
template <typename T>
T MinHeap<T>::extract_min() {      
  T data;                    
  if(heap.empty()){
    cout << "\nThe heap is empty!" << endl;
    exit(1);
  }
  else{
    int i = 0, tmp = heap.size() - 1;                                       // I is for the sentinal loop (while loop below), tmp isnt quite needed but looks cleaner
    swap(heap[0], heap[tmp]);
    data = heap[tmp].data;                                                  // data is equaling the min value to be returned later
    heap.pop_back();                                                        // pop_back removes the last element in the vector
    while(i <= heap.size()){
      int left = (2 * i) + 1, right = (2 * i) + 2;
      if(heap[i].key <= heap[left].key && heap[i].key <= heap[right].key)  // Checks to see if i (starting value of 0) is already the smallest
        break;
      else if(heap[left].key == heap[right].key){                          // checks if left and right equal then chooses left
        swap(heap[i], heap[left]);
        i = left;
      } 
      else if(heap[left].key <= heap[right].key){                          // Checks if left is smaller than right
        swap(heap[i].key, heap[left].key);
        i = left;
      }
      else{
        swap(heap[i].key, heap[right].key);                                // Swaps with right cause after all the checks it should be the smallest
        i = right;
      }
      int has = heap.size();                                               // If it has either left or right, only need to check right
      if(heap[right] <= heap[has]){
        if(heap[i].key <= heap[right].key)
          break;
        else{
          swap(heap[i], heap[right]);
          i = right;
        }
      }
      else{
          swap(heap[i], heap[left]);
          i = left;
      }
    }
    return data;  
  }
}
//*******************************************************************************************
